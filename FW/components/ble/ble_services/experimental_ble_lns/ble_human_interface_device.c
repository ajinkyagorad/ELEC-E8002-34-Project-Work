/* This file was generated by plugin 'Nordic Semiconductor nRF5x v.1.2.2' (BDS version 1.1.3066.0) */

#include "ble_human_interface_device.h"
#include <string.h>
#include "nordic_common.h"
#include "ble_srv_common.h"
#include "app_util.h"
#include "app_util_bds.h"

#define OPCODE_LENGTH 1 /**< Length of opcode inside Human Interface Device packet. */
#define HANDLE_LENGTH 2 /**< Length of handle inside Human Interface Device packet. */

/* TODO Consider changing the max values if encoded data for characteristic/descriptor is fixed length */ 
#define MAX_PROTOCOL_MODE_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Protocol Mode. */ 
#define MAX_REPORT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Report. */ 
#define MAX_REPORT_REFERENCE_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Report Reference. */ 
#define MAX_REPORT_MAP_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Report Map. */ 
#define MAX_EXTERNAL_REPORT_REFERENCE_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted External Report Reference. */ 
#define MAX_BOOT_KEYBOARD_INPUT_REPORT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Boot Keyboard Input Report. */ 
#define MAX_BOOT_KEYBOARD_OUTPUT_REPORT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Boot Keyboard Output Report. */ 
#define MAX_BOOT_MOUSE_INPUT_REPORT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted Boot Mouse Input Report. */ 
#define MAX_HID_INFORMATION_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted HID Information. */ 
#define MAX_HID_CONTROL_POINT_LEN (BLE_L2CAP_MTU_DEF - OPCODE_LENGTH - HANDLE_LENGTH) /**< Maximum size of a transmitted HID Control Point. */ 

/**@brief Function for encoding Protocol Mode Value.
 *
 * @param[in]   p_protocol_mode_value              Protocol Mode Value structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t protocol_mode_protocol_mode_value_encode(protocol_mode_protocol_mode_value_t * p_protocol_mode_value, uint8_t * encoded_buffer)
{
    uint8_t protocol_mode_value;
    protocol_mode_value = p_protocol_mode_value->protocol_mode_value;
    encoded_buffer[0] = protocol_mode_value;
    return 1; 
}

/**@brief Function for encoding Protocol Mode.
 *
 * @param[in]   p_protocol_mode              Protocol Mode characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t protocol_mode_encode(ble_human_interface_device_protocol_mode_t * p_protocol_mode, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += protocol_mode_protocol_mode_value_encode(&p_protocol_mode->protocol_mode_value, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding Protocol Mode Value.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
 static uint8_t protocol_mode_protocol_mode_value_decode(uint8_t data_len, uint8_t * p_data, protocol_mode_protocol_mode_value_t * p_write_val)
 {
    uint8_t pos = 0; 
    p_write_val->protocol_mode_value = (enum_protocol_mode_value_t)p_data[pos++]; 
    return pos;
 }
     
/**@brief Function for decoding Protocol Mode.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t protocol_mode_decode(uint8_t data_len, uint8_t * p_data, ble_human_interface_device_protocol_mode_t * p_write_val)
{
    uint8_t pos = 0;
    pos += protocol_mode_protocol_mode_value_decode((data_len-pos), &p_data[pos], &p_write_val->protocol_mode_value); 

    return pos;
} 
/**@brief Function for encoding Report.
 *
 * @param[in]   p_report              Report characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t report_encode(ble_human_interface_device_report_t * p_report, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_report->report_value;
    return len;
}

/**@brief Function for decoding Report.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t report_decode(uint8_t data_len, uint8_t * p_data, ble_human_interface_device_report_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->report_value = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding Report Type.
 *
 * @param[in]   p_report_type              Report Type structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t report_reference_report_type_encode(human_interface_device_report_reference_report_type_t * p_report_type, uint8_t * encoded_buffer)
{
    uint8_t report_type;
    report_type = p_report_type->report_type;
    encoded_buffer[0] = report_type;
    return 1; 
}

    
/**@brief Function for encoding Report Reference.
 *
 * @param[in]   p_report_reference              Report Reference descriptor structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t report_reference_encode(ble_human_interface_device_report_reference_t * p_report_reference, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_report_reference->report_id;
    len += report_reference_report_type_encode(&p_report_reference->report_type, &encoded_buffer[len]); 
    return len;
}
    
/**@brief Function for encoding Report Map.
 *
 * @param[in]   p_report_map              Report Map characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t report_map_encode(ble_human_interface_device_report_map_t * p_report_map, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_report_map->report_map_value;
    return len;
}

/**@brief Function for encoding External Report Reference.
 *
 * @param[in]   p_external_report_reference              External Report Reference descriptor structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t external_report_reference_encode(ble_human_interface_device_external_report_reference_t * p_external_report_reference, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint8_array_encode(&p_external_report_reference->external_report_reference, &encoded_buffer[len]); 
    return len;
}
    
/**@brief Function for encoding Boot Keyboard Input Report.
 *
 * @param[in]   p_boot_keyboard_input_report              Boot Keyboard Input Report characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t boot_keyboard_input_report_encode(ble_human_interface_device_boot_keyboard_input_report_t * p_boot_keyboard_input_report, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_boot_keyboard_input_report->boot_keyboard_input_report_value;
    return len;
}

/**@brief Function for decoding Boot Keyboard Input Report.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t boot_keyboard_input_report_decode(uint8_t data_len, uint8_t * p_data, ble_human_interface_device_boot_keyboard_input_report_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->boot_keyboard_input_report_value = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding Boot Keyboard Output Report.
 *
 * @param[in]   p_boot_keyboard_output_report              Boot Keyboard Output Report characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t boot_keyboard_output_report_encode(ble_human_interface_device_boot_keyboard_output_report_t * p_boot_keyboard_output_report, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_boot_keyboard_output_report->boot_keyboard_output_report_value;
    return len;
}

/**@brief Function for decoding Boot Keyboard Output Report.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t boot_keyboard_output_report_decode(uint8_t data_len, uint8_t * p_data, ble_human_interface_device_boot_keyboard_output_report_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->boot_keyboard_output_report_value = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding Boot Mouse Input Report.
 *
 * @param[in]   p_boot_mouse_input_report              Boot Mouse Input Report characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t boot_mouse_input_report_encode(ble_human_interface_device_boot_mouse_input_report_t * p_boot_mouse_input_report, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    encoded_buffer[len++] = p_boot_mouse_input_report->boot_mouse_input_report_value;
    return len;
}

/**@brief Function for decoding Boot Mouse Input Report.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t boot_mouse_input_report_decode(uint8_t data_len, uint8_t * p_data, ble_human_interface_device_boot_mouse_input_report_t * p_write_val)
{
    uint8_t pos = 0;
    p_write_val->boot_mouse_input_report_value = p_data[pos++]; 

    return pos;
} 
/**@brief Function for encoding Flags.
 *
 * @param[in]   p_flags              Flags structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t hid_information_flags_encode(hid_information_flags_t * p_flags, uint8_t * encoded_buffer)
{
    uint8_t flags;
    flags = flags | (p_flags->remotewake << 0); 
    flags = flags | (p_flags->normallyconnectable << 1); 
    encoded_buffer[0] = flags;
    return 1; 
}

/**@brief Function for encoding HID Information.
 *
 * @param[in]   p_hid_information              HID Information characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t hid_information_encode(ble_human_interface_device_hid_information_t * p_hid_information, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += bds_uint16_encode(&p_hid_information->bcdhid, &encoded_buffer[len]); 
    encoded_buffer[len++] = p_hid_information->bcountrycode;
    len += hid_information_flags_encode(&p_hid_information->flags, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for encoding HID Control Point Command.
 *
 * @param[in]   p_hid_control_point_command              HID Control Point Command structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t hid_control_point_hid_control_point_command_encode(hid_control_point_hid_control_point_command_t * p_hid_control_point_command, uint8_t * encoded_buffer)
{
    uint8_t hid_control_point_command;
    hid_control_point_command = p_hid_control_point_command->hid_control_point_command;
    encoded_buffer[0] = hid_control_point_command;
    return 1; 
}

/**@brief Function for encoding HID Control Point.
 *
 * @param[in]   p_hid_control_point              HID Control Point characteristic structure to be encoded.
 * @param[out]  p_encoded_buffer   Buffer where the encoded data will be written.
 *
 * @return      Size of encoded data.
 */
static uint8_t hid_control_point_encode(ble_human_interface_device_hid_control_point_t * p_hid_control_point, uint8_t * encoded_buffer)
{
    uint8_t len = 0; 
    len += hid_control_point_hid_control_point_command_encode(&p_hid_control_point->hid_control_point_command, &encoded_buffer[len]); 
    return len;
}

/**@brief Function for decoding HID Control Point Command.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
 static uint8_t hid_control_point_hid_control_point_command_decode(uint8_t data_len, uint8_t * p_data, hid_control_point_hid_control_point_command_t * p_write_val)
 {
    uint8_t pos = 0; 
    p_write_val->hid_control_point_command = (enum_hid_control_point_command_t)p_data[pos++]; 
    return pos;
 }
     
/**@brief Function for decoding HID Control Point.
 *
 * @param[in]   data_len              Length of the field to be decoded.
 * @param[in]   p_data                Buffer where the encoded data is stored.
 * @param[out]  p_write_val           Decoded data.
 *
 * @return      Length of the decoded field.
 */
static uint8_t hid_control_point_decode(uint8_t data_len, uint8_t * p_data, ble_human_interface_device_hid_control_point_t * p_write_val)
{
    uint8_t pos = 0;
    pos += hid_control_point_hid_control_point_command_decode((data_len-pos), &p_data[pos], &p_write_val->hid_control_point_command); 

    return pos;
} 

/**@brief Function for handling the Connect event.
 *
 * @param[in]   p_human_interface_device       Human Interface Device Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_connect(ble_human_interface_device_t * p_human_interface_device, ble_evt_t * p_ble_evt)
{
    p_human_interface_device->conn_handle = p_ble_evt->evt.gap_evt.conn_handle;
}

/**@brief Function for handling the Disconnect event.
 *
 * @param[in]   p_human_interface_device       Human Interface Device Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_disconnect(ble_human_interface_device_t * p_human_interface_device, ble_evt_t * p_ble_evt)
{
    UNUSED_PARAMETER(p_ble_evt);
    p_human_interface_device->conn_handle = BLE_CONN_HANDLE_INVALID;
}

/**@brief Function for handling the Write event.
 *
 * @param[in]   p_human_interface_device       Human Interface Device Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
static void on_write(ble_human_interface_device_t * p_human_interface_device, ble_gatts_evt_write_t * p_ble_evt)
{
    
    if(p_ble_evt->handle == p_human_interface_device->protocol_mode_handles.value_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_PROTOCOL_MODE_EVT_WRITE;
            protocol_mode_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.protocol_mode);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    }
    if(p_ble_evt->handle == p_human_interface_device->report_handles.cccd_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_REPORT_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    } 
    if(p_ble_evt->handle == p_human_interface_device->report_handles.value_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_REPORT_EVT_WRITE;
            report_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.report);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    }
    if(p_ble_evt->handle == p_human_interface_device->boot_keyboard_input_report_handles.cccd_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_BOOT_KEYBOARD_INPUT_REPORT_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    } 
    if(p_ble_evt->handle == p_human_interface_device->boot_keyboard_input_report_handles.value_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_BOOT_KEYBOARD_INPUT_REPORT_EVT_WRITE;
            boot_keyboard_input_report_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.boot_keyboard_input_report);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    }
    if(p_ble_evt->handle == p_human_interface_device->boot_keyboard_output_report_handles.value_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_BOOT_KEYBOARD_OUTPUT_REPORT_EVT_WRITE;
            boot_keyboard_output_report_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.boot_keyboard_output_report);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    }
    if(p_ble_evt->handle == p_human_interface_device->boot_mouse_input_report_handles.cccd_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_BOOT_MOUSE_INPUT_REPORT_EVT_CCCD_WRITE;
            bds_uint16_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.cccd_value);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    } 
    if(p_ble_evt->handle == p_human_interface_device->boot_mouse_input_report_handles.value_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_BOOT_MOUSE_INPUT_REPORT_EVT_WRITE;
            boot_mouse_input_report_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.boot_mouse_input_report);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    }
    if(p_ble_evt->handle == p_human_interface_device->hid_control_point_handles.value_handle)
    {
        if(p_human_interface_device->evt_handler != NULL)
        {
            ble_human_interface_device_evt_t evt;
            evt.evt_type = BLE_HUMAN_INTERFACE_DEVICE_HID_CONTROL_POINT_EVT_WRITE;
            hid_control_point_decode(p_ble_evt->len, p_ble_evt->data, &evt.params.hid_control_point);
            p_human_interface_device->evt_handler(p_human_interface_device, &evt);
        }
    }
}

/**@brief Authorize WRITE request event handler.
 *
 * @details Handles WRITE events from the BLE stack.
 *
 * @param[in]   p_sc_ctrlpt  SC Ctrlpt structure.
 * @param[in]   p_gatts_evt  GATTS Event received from the BLE stack.
 *
 */
static void on_rw_authorize_request(ble_human_interface_device_t * p_human_interface_device, ble_gatts_evt_t * p_gatts_evt)
{
    ble_gatts_evt_rw_authorize_request_t * p_auth_req = &p_gatts_evt->params.authorize_request;
    if (p_auth_req->type == BLE_GATTS_AUTHORIZE_TYPE_WRITE)
    {
        if (   (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_PREP_WRITE_REQ)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_NOW)
            && (p_gatts_evt->params.authorize_request.request.write.op
                != BLE_GATTS_OP_EXEC_WRITE_REQ_CANCEL)
           )
        {
        
            if (p_auth_req->request.write.handle == p_human_interface_device->report_handles.value_handle)
            {
                on_write(p_human_interface_device, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_human_interface_device->boot_keyboard_input_report_handles.value_handle)
            {
                on_write(p_human_interface_device, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_human_interface_device->boot_keyboard_output_report_handles.value_handle)
            {
                on_write(p_human_interface_device, &p_auth_req->request.write);
            }
            if (p_auth_req->request.write.handle == p_human_interface_device->boot_mouse_input_report_handles.value_handle)
            {
                on_write(p_human_interface_device, &p_auth_req->request.write);
            }
        }
    }
}

/**@brief Function for handling BLE events.
 *
 * @param[in]   p_human_interface_device       Human Interface Device Service structure.
 * @param[in]   p_ble_evt   Event received from the BLE stack.
 */
void ble_human_interface_device_on_ble_evt(ble_human_interface_device_t * p_human_interface_device, ble_evt_t * p_ble_evt)
{
    switch (p_ble_evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
            on_connect(p_human_interface_device, p_ble_evt);
            break;
        case BLE_GAP_EVT_DISCONNECTED:
            on_disconnect(p_human_interface_device, p_ble_evt);
            break;
        case BLE_GATTS_EVT_WRITE:
            on_write(p_human_interface_device, &p_ble_evt->evt.gatts_evt.params.write);
            break;
         case BLE_GATTS_EVT_RW_AUTHORIZE_REQUEST:
            on_rw_authorize_request(p_human_interface_device, &p_ble_evt->evt.gatts_evt);
            break;
        default:
            //No implementation needed.
            break;
    }
}

/**@brief Function for initializing the Human Interface Device. */
uint32_t ble_human_interface_device_init(ble_human_interface_device_t * p_human_interface_device, const ble_human_interface_device_init_t * p_human_interface_device_init)
{
    uint32_t err_code;
    ble_uuid_t ble_uuid;

    // Initialize service structure
    p_human_interface_device->evt_handler = p_human_interface_device_init->evt_handler;
    p_human_interface_device->conn_handle = BLE_CONN_HANDLE_INVALID;
    
    BLE_UUID_BLE_ASSIGN(ble_uuid, 0x1812);
        
    // Add service
    err_code = sd_ble_gatts_service_add(BLE_GATTS_SRVC_TYPE_PRIMARY, &ble_uuid, &p_human_interface_device->service_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Protocol Mode characteristic
    ble_human_interface_device_protocol_mode_t protocol_mode_initial_value = p_human_interface_device_init->ble_human_interface_device_protocol_mode_initial_value; 

    uint8_t protocol_mode_encoded_value[MAX_PROTOCOL_MODE_LEN];
    ble_add_char_params_t add_protocol_mode_params;
    memset(&add_protocol_mode_params, 0, sizeof(add_protocol_mode_params));
    
    add_protocol_mode_params.uuid                = 0x2A4E; 
    add_protocol_mode_params.max_len             = MAX_PROTOCOL_MODE_LEN;
    add_protocol_mode_params.init_len            = protocol_mode_encode(&protocol_mode_initial_value, protocol_mode_encoded_value);
    add_protocol_mode_params.p_init_value        = protocol_mode_encoded_value; 
    add_protocol_mode_params.char_props.read     = 1; 
    add_protocol_mode_params.read_access         = SEC_OPEN; 
    add_protocol_mode_params.char_props.write_wo_resp    = 1; 
    add_protocol_mode_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_protocol_mode_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_protocol_mode_params, &(p_human_interface_device->protocol_mode_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Report characteristic
    ble_human_interface_device_report_t report_initial_value = p_human_interface_device_init->ble_human_interface_device_report_initial_value; 
    p_human_interface_device->is_report_write_supported = p_human_interface_device_init->is_report_write_supported;

    uint8_t report_encoded_value[MAX_REPORT_LEN];
    ble_add_char_params_t add_report_params;
    memset(&add_report_params, 0, sizeof(add_report_params));
    
    add_report_params.uuid                = 0x2A4D; 
    add_report_params.max_len             = MAX_REPORT_LEN;
    add_report_params.init_len            = report_encode(&report_initial_value, report_encoded_value);
    add_report_params.p_init_value        = report_encoded_value; 
    add_report_params.char_props.notify   = 1; 
    add_report_params.char_props.read     = 1; 
    add_report_params.read_access         = SEC_OPEN; 
    add_report_params.char_props.write = p_human_interface_device->is_report_write_supported; 
    add_report_params.write_access        = SEC_OPEN; 
    add_report_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_report_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_report_params, &(p_human_interface_device->report_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Report Reference descriptor 
    ble_add_descr_params_t   report_reference;
    uint16_t                 descr_handle;
    uint8_t                  descr_val[MAX_REPORT_REFERENCE_LEN];

    memset(&report_reference, 0, sizeof(report_reference));

    report_reference.uuid             = BLE_UUID_REPORT_REF_DESCR;
    report_reference.read_access      = SEC_OPEN;
    report_reference.write_access     = SEC_NO_ACCESS;
    report_reference.init_len         = MAX_REPORT_REFERENCE_LEN;
    report_reference.max_len          = MAX_REPORT_REFERENCE_LEN;
    report_reference.p_value          = descr_val;

    err_code = descriptor_add(BLE_GATT_HANDLE_INVALID, &report_reference, &descr_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    

    // Add Report Map characteristic
    ble_human_interface_device_report_map_t report_map_initial_value = p_human_interface_device_init->ble_human_interface_device_report_map_initial_value; 

    uint8_t report_map_encoded_value[MAX_REPORT_MAP_LEN];
    ble_add_char_params_t add_report_map_params;
    memset(&add_report_map_params, 0, sizeof(add_report_map_params));
    
    add_report_map_params.uuid                = 0x2A4B; 
    add_report_map_params.max_len             = MAX_REPORT_MAP_LEN;
    add_report_map_params.init_len            = report_map_encode(&report_map_initial_value, report_map_encoded_value);
    add_report_map_params.p_init_value        = report_map_encoded_value; 
    add_report_map_params.char_props.read     = 1; 
    add_report_map_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_report_map_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_report_map_params, &(p_human_interface_device->report_map_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add External Report Reference descriptor 
    ble_add_descr_params_t   external_report_reference;
    uint16_t                 descr_handle;
    uint8_t                  descr_val[MAX_EXTERNAL_REPORT_REFERENCE_LEN];

    memset(&external_report_reference, 0, sizeof(external_report_reference));

    external_report_reference.uuid             = BLE_UUID_REPORT_REF_DESCR;
    external_report_reference.read_access      = SEC_OPEN;
    external_report_reference.write_access     = SEC_NO_ACCESS;
    external_report_reference.init_len         = MAX_EXTERNAL_REPORT_REFERENCE_LEN;
    external_report_reference.max_len          = MAX_EXTERNAL_REPORT_REFERENCE_LEN;
    external_report_reference.p_value          = descr_val;

    err_code = descriptor_add(BLE_GATT_HANDLE_INVALID, &external_report_reference, &descr_handle);
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    }
    

    // Add Boot Keyboard Input Report characteristic
    ble_human_interface_device_boot_keyboard_input_report_t boot_keyboard_input_report_initial_value = p_human_interface_device_init->ble_human_interface_device_boot_keyboard_input_report_initial_value; 
    p_human_interface_device->is_boot_keyboard_input_report_write_supported = p_human_interface_device_init->is_boot_keyboard_input_report_write_supported;

    uint8_t boot_keyboard_input_report_encoded_value[MAX_BOOT_KEYBOARD_INPUT_REPORT_LEN];
    ble_add_char_params_t add_boot_keyboard_input_report_params;
    memset(&add_boot_keyboard_input_report_params, 0, sizeof(add_boot_keyboard_input_report_params));
    
    add_boot_keyboard_input_report_params.uuid                = 0x2A22; 
    add_boot_keyboard_input_report_params.max_len             = MAX_BOOT_KEYBOARD_INPUT_REPORT_LEN;
    add_boot_keyboard_input_report_params.init_len            = boot_keyboard_input_report_encode(&boot_keyboard_input_report_initial_value, boot_keyboard_input_report_encoded_value);
    add_boot_keyboard_input_report_params.p_init_value        = boot_keyboard_input_report_encoded_value; 
    add_boot_keyboard_input_report_params.char_props.notify   = 1; 
    add_boot_keyboard_input_report_params.char_props.read     = 1; 
    add_boot_keyboard_input_report_params.read_access         = SEC_OPEN; 
    add_boot_keyboard_input_report_params.char_props.write = p_human_interface_device->is_boot_keyboard_input_report_write_supported; 
    add_boot_keyboard_input_report_params.write_access        = SEC_OPEN; 
    add_boot_keyboard_input_report_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_boot_keyboard_input_report_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_boot_keyboard_input_report_params, &(p_human_interface_device->boot_keyboard_input_report_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Boot Keyboard Output Report characteristic
    ble_human_interface_device_boot_keyboard_output_report_t boot_keyboard_output_report_initial_value = p_human_interface_device_init->ble_human_interface_device_boot_keyboard_output_report_initial_value; 

    uint8_t boot_keyboard_output_report_encoded_value[MAX_BOOT_KEYBOARD_OUTPUT_REPORT_LEN];
    ble_add_char_params_t add_boot_keyboard_output_report_params;
    memset(&add_boot_keyboard_output_report_params, 0, sizeof(add_boot_keyboard_output_report_params));
    
    add_boot_keyboard_output_report_params.uuid                = 0x2A32; 
    add_boot_keyboard_output_report_params.max_len             = MAX_BOOT_KEYBOARD_OUTPUT_REPORT_LEN;
    add_boot_keyboard_output_report_params.init_len            = boot_keyboard_output_report_encode(&boot_keyboard_output_report_initial_value, boot_keyboard_output_report_encoded_value);
    add_boot_keyboard_output_report_params.p_init_value        = boot_keyboard_output_report_encoded_value; 
    add_boot_keyboard_output_report_params.char_props.read     = 1; 
    add_boot_keyboard_output_report_params.read_access         = SEC_OPEN; 
    add_boot_keyboard_output_report_params.char_props.write    = 1; 
    add_boot_keyboard_output_report_params.char_props.write_wo_resp    = 1; 
    add_boot_keyboard_output_report_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_boot_keyboard_output_report_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_boot_keyboard_output_report_params, &(p_human_interface_device->boot_keyboard_output_report_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add Boot Mouse Input Report characteristic
    ble_human_interface_device_boot_mouse_input_report_t boot_mouse_input_report_initial_value = p_human_interface_device_init->ble_human_interface_device_boot_mouse_input_report_initial_value; 
    p_human_interface_device->is_boot_mouse_input_report_write_supported = p_human_interface_device_init->is_boot_mouse_input_report_write_supported;

    uint8_t boot_mouse_input_report_encoded_value[MAX_BOOT_MOUSE_INPUT_REPORT_LEN];
    ble_add_char_params_t add_boot_mouse_input_report_params;
    memset(&add_boot_mouse_input_report_params, 0, sizeof(add_boot_mouse_input_report_params));
    
    add_boot_mouse_input_report_params.uuid                = 0x2A33; 
    add_boot_mouse_input_report_params.max_len             = MAX_BOOT_MOUSE_INPUT_REPORT_LEN;
    add_boot_mouse_input_report_params.init_len            = boot_mouse_input_report_encode(&boot_mouse_input_report_initial_value, boot_mouse_input_report_encoded_value);
    add_boot_mouse_input_report_params.p_init_value        = boot_mouse_input_report_encoded_value; 
    add_boot_mouse_input_report_params.char_props.notify   = 1; 
    add_boot_mouse_input_report_params.char_props.read     = 1; 
    add_boot_mouse_input_report_params.read_access         = SEC_OPEN; 
    add_boot_mouse_input_report_params.char_props.write = p_human_interface_device->is_boot_mouse_input_report_write_supported; 
    add_boot_mouse_input_report_params.write_access        = SEC_OPEN; 
    add_boot_mouse_input_report_params.cccd_write_access   = SEC_OPEN;
    // 1 for variable length and 0 for fixed length.
    add_boot_mouse_input_report_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_boot_mouse_input_report_params, &(p_human_interface_device->boot_mouse_input_report_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add HID Information characteristic
    ble_human_interface_device_hid_information_t hid_information_initial_value = p_human_interface_device_init->ble_human_interface_device_hid_information_initial_value; 

    uint8_t hid_information_encoded_value[MAX_HID_INFORMATION_LEN];
    ble_add_char_params_t add_hid_information_params;
    memset(&add_hid_information_params, 0, sizeof(add_hid_information_params));
    
    add_hid_information_params.uuid                = 0x2A4A; 
    add_hid_information_params.max_len             = MAX_HID_INFORMATION_LEN;
    add_hid_information_params.init_len            = hid_information_encode(&hid_information_initial_value, hid_information_encoded_value);
    add_hid_information_params.p_init_value        = hid_information_encoded_value; 
    add_hid_information_params.char_props.read     = 1; 
    add_hid_information_params.read_access         = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_hid_information_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_hid_information_params, &(p_human_interface_device->hid_information_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    // Add HID Control Point characteristic
    ble_human_interface_device_hid_control_point_t hid_control_point_initial_value = p_human_interface_device_init->ble_human_interface_device_hid_control_point_initial_value; 

    uint8_t hid_control_point_encoded_value[MAX_HID_CONTROL_POINT_LEN];
    ble_add_char_params_t add_hid_control_point_params;
    memset(&add_hid_control_point_params, 0, sizeof(add_hid_control_point_params));
    
    add_hid_control_point_params.uuid                = 0x2A4C; 
    add_hid_control_point_params.max_len             = MAX_HID_CONTROL_POINT_LEN;
    add_hid_control_point_params.init_len            = hid_control_point_encode(&hid_control_point_initial_value, hid_control_point_encoded_value);
    add_hid_control_point_params.p_init_value        = hid_control_point_encoded_value; 
    add_hid_control_point_params.char_props.write_wo_resp    = 1; 
    add_hid_control_point_params.write_access        = SEC_OPEN; 
    // 1 for variable length and 0 for fixed length.
    add_hid_control_point_params.is_var_len          = 1; 

    err_code = characteristic_add(p_human_interface_device->service_handle, &add_hid_control_point_params, &(p_human_interface_device->hid_control_point_handles));
    if (err_code != NRF_SUCCESS)
    {
        return err_code;
    } 

    return NRF_SUCCESS;
}

/**@brief Function for setting the Protocol Mode. */
uint32_t ble_human_interface_device_protocol_mode_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_protocol_mode_t * p_protocol_mode)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_PROTOCOL_MODE_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = protocol_mode_encode(p_protocol_mode, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->protocol_mode_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Report. */
uint32_t ble_human_interface_device_report_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_report_t * p_report)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_REPORT_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = report_encode(p_report, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->report_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Report Reference. */
uint32_t ble_human_interface_device_report_reference_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_report_reference_t * p_report_reference)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_REPORT_REFERENCE_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = report_reference_encode(p_report_reference, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->report_reference_handles.value_handle, &gatts_value);
} 
/**@brief Function for sending the Report. */
uint32_t ble_human_interface_device_report_send(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_report_t * p_report)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_human_interface_device->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_REPORT_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = report_encode(p_report, encoded_value);
        hvx_params.handle = p_human_interface_device->report_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_human_interface_device->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for setting the Report Map. */
uint32_t ble_human_interface_device_report_map_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_report_map_t * p_report_map)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_REPORT_MAP_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = report_map_encode(p_report_map, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->report_map_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the External Report Reference. */
uint32_t ble_human_interface_device_external_report_reference_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_external_report_reference_t * p_external_report_reference)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_EXTERNAL_REPORT_REFERENCE_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = external_report_reference_encode(p_external_report_reference, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->external_report_reference_handles.value_handle, &gatts_value);
} 
/**@brief Function for setting the Boot Keyboard Input Report. */
uint32_t ble_human_interface_device_boot_keyboard_input_report_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_boot_keyboard_input_report_t * p_boot_keyboard_input_report)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_BOOT_KEYBOARD_INPUT_REPORT_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = boot_keyboard_input_report_encode(p_boot_keyboard_input_report, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->boot_keyboard_input_report_handles.value_handle, &gatts_value);
}

/**@brief Function for sending the Boot Keyboard Input Report. */
uint32_t ble_human_interface_device_boot_keyboard_input_report_send(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_boot_keyboard_input_report_t * p_boot_keyboard_input_report)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_human_interface_device->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_BOOT_KEYBOARD_INPUT_REPORT_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = boot_keyboard_input_report_encode(p_boot_keyboard_input_report, encoded_value);
        hvx_params.handle = p_human_interface_device->boot_keyboard_input_report_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_human_interface_device->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for setting the Boot Keyboard Output Report. */
uint32_t ble_human_interface_device_boot_keyboard_output_report_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_boot_keyboard_output_report_t * p_boot_keyboard_output_report)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_BOOT_KEYBOARD_OUTPUT_REPORT_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = boot_keyboard_output_report_encode(p_boot_keyboard_output_report, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->boot_keyboard_output_report_handles.value_handle, &gatts_value);
}

/**@brief Function for setting the Boot Mouse Input Report. */
uint32_t ble_human_interface_device_boot_mouse_input_report_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_boot_mouse_input_report_t * p_boot_mouse_input_report)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_BOOT_MOUSE_INPUT_REPORT_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = boot_mouse_input_report_encode(p_boot_mouse_input_report, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->boot_mouse_input_report_handles.value_handle, &gatts_value);
}

/**@brief Function for sending the Boot Mouse Input Report. */
uint32_t ble_human_interface_device_boot_mouse_input_report_send(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_boot_mouse_input_report_t * p_boot_mouse_input_report)
{
    uint32_t err_code = NRF_SUCCESS;

    if (p_human_interface_device->conn_handle != BLE_CONN_HANDLE_INVALID)
    {
        ble_gatts_hvx_params_t hvx_params;
        uint8_t encoded_value[MAX_BOOT_MOUSE_INPUT_REPORT_LEN];
        uint16_t hvx_len;

        // Initialize value struct.
        memset(&hvx_params, 0, sizeof(hvx_params));

        hvx_len           = boot_mouse_input_report_encode(p_boot_mouse_input_report, encoded_value);
        hvx_params.handle = p_human_interface_device->boot_mouse_input_report_handles.value_handle;
        hvx_params.type   = BLE_GATT_HVX_NOTIFICATION;
        hvx_params.p_len  = &hvx_len;
        hvx_params.offset = 0;
        hvx_params.p_data = encoded_value;

        err_code = sd_ble_gatts_hvx(p_human_interface_device->conn_handle, &hvx_params);
    }
    else
    {
        err_code = NRF_ERROR_INVALID_STATE;
    }

    return err_code;
}

/**@brief Function for setting the HID Information. */
uint32_t ble_human_interface_device_hid_information_set(ble_human_interface_device_t * p_human_interface_device, ble_human_interface_device_hid_information_t * p_hid_information)
{
    ble_gatts_value_t gatts_value;
    uint8_t encoded_value[MAX_HID_INFORMATION_LEN];

    // Initialize value struct.
    memset(&gatts_value, 0, sizeof(gatts_value));

    gatts_value.len     = hid_information_encode(p_hid_information, encoded_value);
    gatts_value.offset  = 0;
    gatts_value.p_value = encoded_value;

    return sd_ble_gatts_value_set(p_human_interface_device->conn_handle, p_human_interface_device->hid_information_handles.value_handle, &gatts_value);
}

